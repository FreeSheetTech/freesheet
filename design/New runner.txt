New Runner
==========

- Object with functions
- Functions generated almost directly from FS expressions
- Will still need Operations
- Will still need some of code generator
- Functions reference others via this
- Inputs are stored as a list
- Named values are also functions
- Need to know when to take all values of an input or only latest
- When change a function, need to re-run all inputs
- Need to know which function values have changed
- Rx may still have a place
- Should value changes be notified where still has same value - event stream view?
- Aim: to produce 'normal' JavaScript that would run as a standalone program

Working on stream instead of values
-----------------------------------
- Convention: all_xyz means the stream of xyz's instead of the latest value  ( allXyz too?)
- Only collected if needed
- If used in a function, create an all_xyz that returns this.stored.xyz
- Need to update stored.xyz after each input - but only if it was affected?
- Need to update stored.xyz before it is used
- Need to ensure stored.xyz updated exactly once for each input
- Need to update stored.xyz for each partial input
- Poss: input counter
- Poss: inputs received flag
- all_xyz adds the latest input to stored.xyz before returning it if not up to date, then marks as up to date
- Partial input flags all the stored.xyz as out of date
- After each partial input, call each all_xyz to ensure it stores the latest value
- Don't call other functions until input complete
- Could hold all values for all named values to help debugging
- Previous one would be useful for many things

Stage 1 of all_xyz
------------------
    - Collect all values of every named value in stored.xyz
    - Init stored.xyz to []
    - Flag upToDate on the array
    - Add an all_xyz function for every named value
    - partial input sets all upToDate to false
    - all_xyz calls xyz() and pushes on array if upToDate false, sets upTodate to true
    - Call every all_xyz after each partial input to ensure that input recorded

Functions producing multiple outputs for one input
--------------------------------------------------
- eg flatten/unpackLists
- When function called, need to know it is multiple outputs, not just one sequence
- Only reason need to see all of them and not just last one is if accumulating a downstream value in all_
- Poss: put each value in turn in the slot for that name, then recalculate every down stream all_
- Design problem: opposition of event push and recalculation pull viewpoints
- If can send partial input to a primary input, maybe can do it to an intermediate named value too
- Slots can take place of the subjects, hold Invalid value to show need recalculating, use value as cache
- If each slot calls its function to get new value, sets in its slot, then invalidates its descendants, then recalculates every all_
- If multiple output values, set each in slot and recalculate in turn
- Need to get multiple sheet value change events
- If subscribed to value changes on all_xyz, that would force separate events


Multiple outputs example
------------------------
  transactionList = input
  transactions = unpack(transactionList)
  creditTotal = sum(fromEach(select(all_transactions, type = 'C'), amount)
  debitTransactions = select(all_transactions, type = 'D')
  debitTotal = sum(fromEach(debitTransactions, amount))

Events on sheet
---------------
- Input event goes to an input from outside
- Sheet functions can raise events on sheet to any slot
- A sheet function may queue up multiple (or zero) events to its own slot - or others?
- Could have debugging or state restoration events to any slot from outside
- When ask for slot value (single):
  - this will always be a pull from a dependent slot
  - if invalid, run function to get next slot value and put in slot
  - return slot value
- Event queue and event loop:
  - Input events always go in a queue with name and value
  - From outside, queue the event and start event loop
  - Event loop takes first event and sends to sheet until queue empty
  - When queue empty, do input complete (recalculate and send value changes to listeners)
- Send to sheet
  - Puts that value in the slot
  - If the value has changed, invalidate all dependent slots
  - Whether changed or not, recalculate every dependent all_ slot
- When ask for slot value (multiple):
  - this will always be a pull from a dependent slot or value change observer
  - if invalid, run function to get next slot values and put first one in slot
  - queue up remaining values as events for this slot
  - return slot value
- Functions just do what they say on tin - return multiple values if there are multiple values - sheet uses that


To do
-----
- Do we need subjects for functions with args?
- Do we need subjects at all?



Possible optimisations
----------------------
- Cache function values
- Work out what functions might be affected by an input
- Memoise functions for certain arguments
- Autogenerate objects with functions attached
- Change full scans to fold operations using only the latest value
- In production mode, reduce the number of previous held
- Wrap all functions generated in a manager function that can memoise and trace
- Could profile time spent in each function and number of calls
- Store dependencies of each function and invalidate only those
- Only invalidate if function value changes (so need previous)
- Don't depend on people writing functions a certain way
- Only produce sheet value change events if anyone listening
- Only produce unbuffered value change events if anyone listening
- Only invalidate dependents after an event if your value has changed

Incremental updates
-------------------
- How to translate functions into previous plus latest input
- If every aggregate function is a fold, not matter if have lots of sums inside a final aggregate
- Memoise aggregate functions by arguments
- Functions get access to previous value plus any other data they want to keep eg previous distinct values, no of values
- A select just needs the previous values, plus new one, plus the select function

Memoising
---------
- Each usage of a function gets a unique id passed to it somehow OR each usage of a function is wrapped in a memoiser
- All function calls given their own name even if they are sub-exprs - would only work within a no-args function

Change prediction
-----------------
- How limit updates to only the entities affected by an input eg account and new transaction

Storing state
-------------
- How to cache and persist values so far for an entity
- Memoise with id arg = entity
- Don't memoise functions that don't call other functions
- Memoise functions that call an all_xyz anywhere below them
- Memoise no-args functions
